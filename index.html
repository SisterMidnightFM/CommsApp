<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SMFM Instagram Comms App V2.1</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="icon" href="favicon.png" type="image/x-icon">
</head>
<body>
    <!-- Main header -->
    <header>
        SMFM Instagram Comms App V2.1
    </header>

    <!-- App container with split layout -->
    <div class="app-container">
        <!-- Left side: Controls panel -->
        <div class="controls-panel">
            <!-- Stage 1: Upload Image -->
            <div class="stage" id="stage1">
                <div class="stage-title">Stage 1: Upload Image</div>
                <input type="file" id="imageUpload" accept="image/*">
                <p>Image will be automatically resized to 1080px Ã— 1350px - 4:5 aspect ratio </p>
            </div>

            <!-- Add buttons for selecting template color -->
            <div class="stage" id="stageTemplate">
                <div class="stage-title">Select Template Colour</div>
                <button id="whiteTemplateBtn">White</button>
                <button id="blackTemplateBtn">Black</button>
            </div>
            
            <!-- Stage 2: Adjust Image -->
            <div class="stage" id="stage2">
                <div class="stage-title">Stage 2: Adjust Image</div>
                <label for="zoomSlider">Zoom: <span id="zoomValue" class="range-value">0%</span></label>
                <input type="range" id="zoomSlider" min="-50" max="150" value="0">
                
                <label for="xPosSlider">X Position: <span id="xPosValue" class="range-value">0</span></label>
                <input type="range" id="xPosSlider" min="-100" max="100" value="0">
                
                <label for="yPosSlider">Y Position: <span id="yPosValue" class="range-value">0</span></label>
                <input type="range" id="yPosSlider" min="-100" max="100" value="0">
                
                <p><small>Tip: You can also click and drag directly on the image to adjust position</small></p>
            </div>

            <!-- Stage 3: Add Text -->
            <div class="stage" id="stage3">
                <div class="stage-title">Stage 3: Add Name and Date</div>
                <label for="showName">Show Name:</label>
                <input type="text" id="showName" placeholder="Enter show name">
                
                <label for="showDate">Show Date:</label>
                <input type="datetime-local" id="showDate">

                <label for="showLength">Show Length:</label>
                <select id="showLength">
                    <option value="">Select duration (optional)</option>
                    <option value="30">30 minutes</option>
                    <option value="60">1 hour</option>
                    <option value="90">1 hour 30 minutes</option>
                    <option value="120">2 hours</option>
                    <option value="150">2 hours 30 minutes</option>
                    <option value="180">3 hours</option>
                </select>

                <label for="textSizeSlider">Text Size: <span id="textSizeValue" class="range-value">33pt</span></label>
                <input type="range" id="textSizeSlider" min="10" max="50" value="33">
                
                <label for="tag1">Genre/Vibe 1:</label>
                <input type="text" id="tag1" placeholder="Enter first tag" maxlength="15">
                
                <label for="tag2">Genre/Vibe 2:</label>
                <input type="text" id="tag2" placeholder="Enter second tag" maxlength="15">
            </div>

            <!-- Stage 4: Export -->
            <div class="stage" id="stage4">
                <div class="stage-title">Stage 4: Export</div>
                <label for="fileName">File Name:</label>
                <input type="text" id="fileName" readonly>
                <button id="exportBtn">Export Image</button>
                <p id="exportStatus"></p>
            </div>
        </div>

        <!-- Right side: Preview panel -->
        <div class="preview-panel">
            <div class="canvas-container">
                <canvas id="previewCanvas"></canvas>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        const canvas = document.getElementById('previewCanvas');
        const ctx = canvas.getContext('2d');

        // Configuration object - will be loaded from config.json
        let config = null;

        // Standard Instagram size (fallback defaults)
        let CANVAS_WIDTH = 1080;
        let CANVAS_HEIGHT = 1350;

        // Image holders
        let userImage = null;
        let templateImage = null;

        // Current settings
        const settings = {
            zoom: 0,
            xPos: 0,
            yPos: 0,
            showName: '',
            showDate: '',
            showLength: '', // Show duration in minutes
            textSize: 33, // Default text size - will be updated from config
            fontColor: 'white', // Default font color - will be updated from config
            tag1: '',
            tag2: ''
        };

        // Load configuration file and initialize app
        async function loadConfig() {
            try {
                // Add cache busting to ensure fresh config is loaded
                const response = await fetch('config.json?v=' + Date.now());
                config = await response.json();

                // Update canvas dimensions from config
                CANVAS_WIDTH = config.canvas.width;
                CANVAS_HEIGHT = config.canvas.height;
                canvas.width = CANVAS_WIDTH;
                canvas.height = CANVAS_HEIGHT;

                // Update default settings from config
                settings.textSize = config.textSizes.showNameDefault;
                settings.fontColor = config.colors.defaultFontColor;

                // Update slider ranges from config
                document.getElementById('zoomSlider').min = config.controls.zoom.min;
                document.getElementById('zoomSlider').max = config.controls.zoom.max;
                document.getElementById('zoomSlider').value = config.controls.zoom.default;

                document.getElementById('xPosSlider').min = config.controls.position.min;
                document.getElementById('xPosSlider').max = config.controls.position.max;
                document.getElementById('xPosSlider').value = config.controls.position.default;

                document.getElementById('yPosSlider').min = config.controls.position.min;
                document.getElementById('yPosSlider').max = config.controls.position.max;
                document.getElementById('yPosSlider').value = config.controls.position.default;

                document.getElementById('textSizeSlider').min = config.textSizes.showNameMin;
                document.getElementById('textSizeSlider').max = config.textSizes.showNameMax;
                document.getElementById('textSizeSlider').value = config.textSizes.showNameDefault;
                document.getElementById('textSizeValue').textContent = config.textSizes.showNameDefault + 'pt';

                // Set initial datetime value
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                document.getElementById('showDate').value = `${year}-${month}-${day}T${hours}:${minutes}`;

                // Load default template image
                const defaultTemplate = config.templates.defaultTemplate === 'white'
                    ? config.templates.whiteTemplatePath
                    : config.templates.blackTemplatePath;
                loadTemplateImage(defaultTemplate);

                // Initialize canvas
                initializeCanvas();
                updateFileName();

            } catch (error) {
                console.error('Error loading config:', error);
                alert('Error loading configuration file. Using default settings.');
                // Fall back to defaults and continue
                canvas.width = CANVAS_WIDTH;
                canvas.height = CANVAS_HEIGHT;
                loadTemplateImage('template_white.png');
                initializeCanvas();
                updateFileName();
            }
        }

        // Call loadConfig on startup
        loadConfig();

        // STAGE 1: Image Upload logic
        document.getElementById('imageUpload').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    loadUserImage(event.target.result);
                };
                reader.readAsDataURL(file);
            }
        });

        // STAGE 2: Adjust image logic
        document.getElementById('zoomSlider').addEventListener('input', function(e) {
            settings.zoom = parseInt(e.target.value);
            document.getElementById('zoomValue').textContent = settings.zoom + '%';

            // Constrain position when zoom changes to prevent edges from showing
            constrainPosition();

            // Update slider values to reflect constrained positions
            document.getElementById('xPosSlider').value = settings.xPos;
            document.getElementById('xPosValue').textContent = Math.round(settings.xPos);
            document.getElementById('yPosSlider').value = settings.yPos;
            document.getElementById('yPosValue').textContent = Math.round(settings.yPos);

            redrawCanvas();
        });

        document.getElementById('xPosSlider').addEventListener('input', function(e) {
            settings.xPos = parseInt(e.target.value);
            constrainPosition();
            document.getElementById('xPosSlider').value = settings.xPos;
            document.getElementById('xPosValue').textContent = Math.round(settings.xPos);
            redrawCanvas();
        });

        document.getElementById('yPosSlider').addEventListener('input', function(e) {
            settings.yPos = parseInt(e.target.value);
            constrainPosition();
            document.getElementById('yPosSlider').value = settings.yPos;
            document.getElementById('yPosValue').textContent = Math.round(settings.yPos);
            redrawCanvas();
        });

        // STAGE 3: Text input logic
        document.getElementById('showName').addEventListener('input', function(e) {
            settings.showName = e.target.value;
            updateFileName();
            redrawCanvas();
        });

        document.getElementById('showDate').addEventListener('change', function(e) {
            // Format the date for display
            const date = new Date(e.target.value);
            const options = {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            };
            settings.showDate = date.toLocaleDateString('en-US', options);
            updateFileName();
            redrawCanvas();
        });

        // Show length dropdown
        document.getElementById('showLength').addEventListener('change', function(e) {
            settings.showLength = e.target.value;
            redrawCanvas();
        });

        // Text size slider
        document.getElementById('textSizeSlider').addEventListener('input', function(e) {
            settings.textSize = parseInt(e.target.value);
            document.getElementById('textSizeValue').textContent = settings.textSize + 'pt';
            redrawCanvas();
        });

        // Tag input logic
        document.getElementById('tag1').addEventListener('input', function(e) {
            settings.tag1 = e.target.value;
            redrawCanvas();
        });

        document.getElementById('tag2').addEventListener('input', function(e) {
            settings.tag2 = e.target.value;
            redrawCanvas();
        });

        // STAGE 4: Export logic
        document.getElementById('exportBtn').addEventListener('click', function() {
            try {
                // Create a download link for the canvas content
                const exportStatus = document.getElementById('exportStatus');
                exportStatus.textContent = "Preparing download...";
                
                // Make sure template is loaded
                if (!templateImage || !templateImage.complete) {
                    exportStatus.textContent = "Error: Template image not loaded. Try again.";
                    return;
                }
                
                const fileName = document.getElementById('fileName').value || "image";
                const link = document.createElement('a');
                link.download = fileName + '.png';
                
                // Use timeout to ensure UI updates before heavy processing
                setTimeout(() => {
                    try {
                        // Get canvas data and trigger download
                        link.href = canvas.toDataURL('image/png');
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        exportStatus.textContent = "Download complete!";
                        
                        // Clear status message after 3 seconds
                        setTimeout(() => {
                            exportStatus.textContent = "";
                        }, 3000);
                    } catch (err) {
                        console.error("Export error:", err);
                        exportStatus.textContent = "Error exporting: " + err.message;
                    }
                }, 100);
            } catch (err) {
                console.error("Export setup error:", err);
                document.getElementById('exportStatus').textContent = "Error setting up export: " + err.message;
            }
        });

        // Add event listeners for template selection buttons
        document.getElementById('whiteTemplateBtn').addEventListener('click', function() {
            const templatePath = config ? config.templates.whiteTemplatePath : 'template_white.png';
            loadTemplateImage(templatePath);
            settings.fontColor = 'white'; // Set font color to white
            redrawCanvas(); // Redraw the canvas with the updated font color
        });

        document.getElementById('blackTemplateBtn').addEventListener('click', function() {
            const templatePath = config ? config.templates.blackTemplatePath : 'template_black.png';
            loadTemplateImage(templatePath);
            settings.fontColor = 'black'; // Set font color to black
            redrawCanvas(); // Redraw the canvas with the updated font color
        });

        // Function to load the template image
        function loadTemplateImage(templateSrc) {
            templateImage = new Image();
            templateImage.onload = function() {
                redrawCanvas();
            };
            templateImage.src = templateSrc;
            templateImage.onerror = function(e) {
                console.error('Error loading template image:', e);
                alert(`Could not load the template image: ${templateSrc}. Make sure it exists in the app folder.`);
            };
        }

        // Function to load and process user image
        function loadUserImage(src) {
            // Create a new image object
            const img = new Image();
            img.onload = function() {
                userImage = img;
                
                // Reset sliders when new image is loaded
                document.getElementById('zoomSlider').value = 0;
                document.getElementById('zoomValue').textContent = '0%';
                document.getElementById('xPosSlider').value = 0;
                document.getElementById('xPosValue').textContent = '0';
                document.getElementById('yPosSlider').value = 0;
                document.getElementById('yPosValue').textContent = '0';
                
                // Reset settings
                settings.zoom = 0;
                settings.xPos = 0;
                settings.yPos = 0;
                
                // Calculate initial zoom to fit entire image
                calculateInitialZoom();
                
                // Redraw canvas with new image
                redrawCanvas();
            };
            img.src = src;
        }
        
        // Calculate initial zoom to ensure image always covers canvas (no edges visible)
        function calculateInitialZoom() {
            if (!userImage) return;

            // Set zoom slider minimum to 0
            // 0 = exact coverage, positive values = larger than coverage
            const zoomSlider = document.getElementById('zoomSlider');
            zoomSlider.min = 0;

            // Get initial zoom percentage from config (e.g., 5 means 5% larger than minimum coverage)
            const initialZoomPercent = config ? config.image.initialZoomFactor : 5;

            // Update zoom slider and settings
            zoomSlider.value = initialZoomPercent;
            document.getElementById('zoomValue').textContent = initialZoomPercent + '%';
            settings.zoom = initialZoomPercent;
        }

        // Function to calculate maximum allowed position offsets to prevent edges from showing
        function getMaxPositionOffsets() {
            if (!userImage) return { maxX: 0, maxY: 0 };

            const imgWidth = userImage.width;
            const imgHeight = userImage.height;
            const canvasRatio = CANVAS_WIDTH / CANVAS_HEIGHT;
            const imgRatio = imgWidth / imgHeight;
            const dragMultiplier = config ? config.controls.position.dragMultiplier : 5;

            // Calculate minimum scale factor needed to cover entire canvas
            let minScaleFactor;
            if (imgRatio > canvasRatio) {
                minScaleFactor = CANVAS_HEIGHT / imgHeight;
            } else {
                minScaleFactor = CANVAS_WIDTH / imgWidth;
            }

            // Apply user's zoom on top of minimum coverage
            const zoomMultiplier = 1 + (settings.zoom / 100);
            const actualScaleFactor = minScaleFactor * zoomMultiplier;

            // Calculate actual drawn dimensions
            const drawWidth = imgWidth * actualScaleFactor;
            const drawHeight = imgHeight * actualScaleFactor;

            // Calculate how much the image overhangs the canvas on each side
            const xOverhang = Math.max(0, (drawWidth - CANVAS_WIDTH) / 2);
            const yOverhang = Math.max(0, (drawHeight - CANVAS_HEIGHT) / 2);

            // Convert overhang to position units (divide by dragMultiplier)
            const maxX = xOverhang / dragMultiplier;
            const maxY = yOverhang / dragMultiplier;

            return { maxX, maxY };
        }

        // Function to constrain position within valid bounds
        function constrainPosition() {
            const { maxX, maxY } = getMaxPositionOffsets();

            // Clamp xPos and yPos within allowed range
            settings.xPos = Math.max(-maxX, Math.min(maxX, settings.xPos));
            settings.yPos = Math.max(-maxY, Math.min(maxY, settings.yPos));
        }

        // Function to update the file name based on show name and date
        function updateFileName() {
            // Get date info from the date picker
            let dateStr = "";
            if (document.getElementById('showDate').value) {
                const date = new Date(document.getElementById('showDate').value);
                dateStr = date.toISOString().split('T')[0]; // Use YYYY-MM-DD format
            }
            
            // Replace spaces and special characters with underscores
            const sanitizedName = settings.showName.replace(/[^a-zA-Z0-9]/g, '_');
            const sanitizedDate = dateStr.replace(/[^a-zA-Z0-9]/g, '_');
            
            // Combine name and date for filename
            const fileName = sanitizedName + '_' + sanitizedDate;
            document.getElementById('fileName').value = fileName;
        }

        // Function to draw a tag box with text
        function drawTagBox(text, x, y) {
            if (!text) return;

            // Get config values or use defaults
            const tagFontSize = config ? config.textSizes.tag : 24;
            const tagFont = config ? config.fonts.tagFont : 'Font2';
            const paddingX = config ? config.tagBox.paddingX : 20;
            const paddingY = config ? config.tagBox.paddingY : 12;
            const borderWidth = config ? config.tagBox.borderWidth : 3;
            const textWidthBuffer = config ? config.tagBox.textWidthBuffer : 5;

            // Set font for measuring text
            ctx.font = `${tagFontSize}pt ${tagFont}`;

            // Measure the transformed text
            const transformedText = text.toUpperCase();
            const metrics = ctx.measureText(transformedText);
            const textWidth = metrics.width + textWidthBuffer;
            const textHeight = tagFontSize;

            // Calculate box dimensions
            const boxWidth = textWidth + paddingX * 2;
            const boxHeight = textHeight + paddingY * 2;

            // Draw the box border
            ctx.strokeStyle = settings.fontColor || 'white';
            ctx.lineWidth = borderWidth;
            ctx.strokeRect(x, y - boxHeight / 2, boxWidth, boxHeight);

            // Draw the text
            ctx.fillStyle = settings.fontColor || 'white';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText(transformedText, x + paddingX, y);
        }

        // Main function to redraw the canvas with all current settings
        function redrawCanvas() {
            // Clear the canvas
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Background fill (in case image doesn't cover canvas)
            const bgColor = config ? config.canvas.backgroundColor : '#000000';
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Draw user image if available
            if (userImage) {
                const imgWidth = userImage.width;
                const imgHeight = userImage.height;
                const canvasRatio = CANVAS_WIDTH / CANVAS_HEIGHT;
                const imgRatio = imgWidth / imgHeight;

                // Calculate minimum scale factor needed to cover entire canvas
                let minScaleFactor;
                if (imgRatio > canvasRatio) {
                    // Image is wider - scale based on HEIGHT to ensure canvas is filled
                    minScaleFactor = CANVAS_HEIGHT / imgHeight;
                } else {
                    // Image is taller - scale based on WIDTH to ensure canvas is filled
                    minScaleFactor = CANVAS_WIDTH / imgWidth;
                }

                // Apply user's zoom on top of minimum coverage
                // settings.zoom is a percentage (0 = exact coverage, 10 = 10% larger, etc.)
                const zoomMultiplier = 1 + (settings.zoom / 100);
                const actualScaleFactor = minScaleFactor * zoomMultiplier;

                // Calculate final draw dimensions
                const drawWidth = imgWidth * actualScaleFactor;
                const drawHeight = imgHeight * actualScaleFactor;

                const dragMultiplier = config ? config.controls.position.dragMultiplier : 5;
                const xOffset = (CANVAS_WIDTH - drawWidth) / 2 + settings.xPos * dragMultiplier;
                const yOffset = (CANVAS_HEIGHT - drawHeight) / 2 + settings.yPos * dragMultiplier;

                ctx.drawImage(userImage, xOffset, yOffset, drawWidth, drawHeight);
            } else {
                const placeholderBg = config ? config.colors.placeholderBackground : '#eeeeee';
                const placeholderText = config ? config.colors.placeholderText : '#999999';
                const dateTimeFont = config ? config.fonts.dateTimeFont : 'Font2';

                ctx.fillStyle = placeholderBg;
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                ctx.fillStyle = placeholderText;
                ctx.font = `24px ${dateTimeFont}`;
                ctx.textAlign = 'center';
                ctx.fillText('Upload an image to get started', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
            }

            // Draw template image on top
            if (templateImage) {
                ctx.drawImage(templateImage, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            }

            // Set font for text overlay - using dynamic font color and custom size
            const showNameFont = config ? config.fonts.showNameFont : 'CustomFont';
            ctx.font = `${settings.textSize}pt ${showNameFont}`;
            ctx.fillStyle = settings.fontColor || 'white'; // Default to white if not set
            ctx.textAlign = 'center';

            // Draw show name text with wrapping
            if (settings.showName) {
                const maxWidth = config ? config.textPositions.showName.maxWidth : 800;
                const lineHeightMultiplier = config ? config.textPositions.showName.lineHeightMultiplier : 1.6;
                const lineHeight = settings.textSize * lineHeightMultiplier;
                const centerY = config ? config.textPositions.showName.centerY : 1100;
                const showNameUpperCase = settings.showName.toUpperCase();
                wrapText(ctx, showNameUpperCase, CANVAS_WIDTH / 2, centerY, maxWidth, lineHeight);
            }

            // Draw show date text
            if (settings.showDate) {
                const date = new Date(document.getElementById('showDate').value);

                // Calculate time display (range if show length is selected, single time otherwise)
                let timeDisplay;
                if (settings.showLength) {
                    // Calculate end time based on show length
                    const startDate = new Date(date);
                    const endDate = new Date(date.getTime() + parseInt(settings.showLength) * 60000);

                    // Format start time
                    const startHour = startDate.getHours();
                    const startMin = startDate.getMinutes();
                    const startPeriod = startHour >= 12 ? 'PM' : 'AM';
                    const startHour12 = startHour % 12 || 12;
                    const startTimeStr = startMin > 0 ? `${startHour12}.${String(startMin).padStart(2, '0')}` : `${startHour12}`;

                    // Format end time
                    const endHour = endDate.getHours();
                    const endMin = endDate.getMinutes();
                    const endPeriod = endHour >= 12 ? 'PM' : 'AM';
                    const endHour12 = endHour % 12 || 12;
                    const endTimeStr = endMin > 0 ? `${endHour12}.${String(endMin).padStart(2, '0')}` : `${endHour12}`;

                    // Build time range string
                    if (startPeriod === endPeriod) {
                        // Same period: "7-9.30AM"
                        timeDisplay = `${startTimeStr}-${endTimeStr}${endPeriod}`;
                    } else {
                        // Different periods: "11.30AM-1PM"
                        timeDisplay = `${startTimeStr}${startPeriod}-${endTimeStr}${endPeriod}`;
                    }
                } else {
                    // No show length selected, just show single time
                    const timeOptions = { hour: 'numeric', hour12: true };
                    timeDisplay = date.toLocaleTimeString('en-US', timeOptions).toLowerCase().toUpperCase();
                }

                const dayName = date.toLocaleDateString('en-US', { weekday: 'long' }).toLowerCase().toUpperCase();
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const year = String(date.getFullYear()).slice(-2);
                const formattedDate = `${day}.${month}.${year}`.toUpperCase();

                const rightMargin = config ? config.textPositions.dateTime.rightMargin : 50;
                const timeX = CANVAS_WIDTH - rightMargin;
                const timeY = config ? config.textPositions.dateTime.timeY : 1191;
                const dayNameX = CANVAS_WIDTH - rightMargin;
                const dayNameYOffset = config ? config.textPositions.dateTime.dayNameYOffset : 42;
                const dayNameY = timeY + dayNameYOffset;
                const dateX = CANVAS_WIDTH - rightMargin;
                const dateYOffset = config ? config.textPositions.dateTime.dateYOffset : 84;
                const dateY = timeY + dateYOffset;

                const dateTimeFontSize = config ? config.textSizes.dateTime : 28;
                const dateTimeFont = config ? config.fonts.dateTimeFont : 'Font2';
                ctx.font = `${dateTimeFontSize}pt ${dateTimeFont}`;
                ctx.fillStyle = settings.fontColor || 'white'; // Default to white if not set
                ctx.textAlign = 'right';

                ctx.fillText(timeDisplay, timeX, timeY);
                ctx.fillText(dayName, dayNameX, dayNameY);
                ctx.fillText(formattedDate, dateX, dateY);
            }

            // Draw tags
            const leftMargin = config ? config.textPositions.tags.leftMargin : 30;
            const tagXOffset = config ? config.textPositions.tags.xOffset : 12;
            const tagY = config ? config.textPositions.tags.baseY : 1200;
            const tagSpacing = config ? config.textPositions.tags.spacing : 60;

            if (settings.tag1) {
                drawTagBox(settings.tag1, leftMargin + tagXOffset, tagY); // Draw Tag 1
            }

            if (settings.tag2) {
                const tag2Y = tagY + tagSpacing; // Position Tag 2 below Tag 1
                drawTagBox(settings.tag2, leftMargin + tagXOffset, tag2Y); // Draw Tag 2
            }
        }

        // Function to wrap text
        function wrapText(context, text, x, y, maxWidth, lineHeight) {
            const words = text.split(' ');
            let line = '';
            let yPos = y;

            for (let i = 0; i < words.length; i++) {
                const testLine = line + words[i] + ' ';
                const metrics = context.measureText(testLine);
                const testWidth = metrics.width;
                
                if (testWidth > maxWidth && i > 0) {
                    context.fillText(line, x, yPos);
                    line = words[i] + ' ';
                    yPos += lineHeight;
                } else {
                    line = testLine;
                }
            }
            
            context.fillText(line, x, yPos);
        }

        // Adjust canvas size when window is resized
        window.addEventListener('resize', function() {
            // We maintain the aspect ratio but scale down the preview if needed
            redrawCanvas();
        });

        // Initialize the canvas with a placeholder
        function initializeCanvas() {
            const placeholderBg = config ? config.colors.placeholderBackground : '#eeeeee';
            const placeholderText = config ? config.colors.placeholderText : '#999999';
            const dateTimeFont = config ? config.fonts.dateTimeFont : 'Font2';

            ctx.fillStyle = placeholderBg;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            ctx.fillStyle = placeholderText;
            ctx.font = `24px ${dateTimeFont}`;
            ctx.textAlign = 'center';
            ctx.fillText('Upload an image to get started', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);

            // Ensure the text size is applied during initialization
            document.getElementById('textSizeSlider').value = settings.textSize;
            document.getElementById('textSizeValue').textContent = settings.textSize + 'pt';
            redrawCanvas(); // Redraw the canvas with the correct font size
        }
        
        // ---- Add drag functionality for image positioning ----
        
        // Variables to track dragging state
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        // Get the actual display size of the canvas to calculate the scaling factor
        function getCanvasScaleFactor() {
            const displayedWidth = canvas.clientWidth;
            const actualWidth = canvas.width;
            return actualWidth / displayedWidth;
        }
        
        // Mouse down event - start dragging
        canvas.addEventListener('mousedown', function(e) {
            if (!userImage) return; // Only allow dragging if there's an image
            
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            
            // Change cursor to indicate grabbing
            canvas.style.cursor = 'grabbing';
        });
        
        // Mouse move event - update position while dragging
        window.addEventListener('mousemove', function(e) {
            if (!isDragging) return;

            // Calculate the movement delta
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;

            // Get scaling factor to adjust mouse movement to canvas coordinates
            const scaleFactor = getCanvasScaleFactor();

            // Update the position with scaled movement
            settings.xPos += deltaX / scaleFactor;
            settings.yPos += deltaY / scaleFactor;

            // Constrain position to prevent image edges from showing
            constrainPosition();

            // Update sliders
            document.getElementById('xPosSlider').value = settings.xPos;
            document.getElementById('yPosSlider').value = settings.yPos;
            document.getElementById('xPosValue').textContent = Math.round(settings.xPos);
            document.getElementById('yPosValue').textContent = Math.round(settings.yPos);

            // Redraw canvas with new position
            redrawCanvas();

            // Update last position
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });
        
        // Mouse up event - stop dragging
        window.addEventListener('mouseup', function() {
            if (isDragging) {
                isDragging = false;
                canvas.style.cursor = 'move';
            }
        });
        
        // Mouse leave event - stop dragging if cursor leaves the window
        window.addEventListener('mouseleave', function() {
            if (isDragging) {
                isDragging = false;
                canvas.style.cursor = 'move';
            }
        });

        // Helper function to get ordinal suffix (1st, 2nd, 3rd, etc.)
        function getOrdinalSuffix(day) {
            if (day > 3 && day < 21) return 'th';
            switch (day % 10) {
                case 1: return 'st';
                case 2: return 'nd';
                case 3: return 'rd';
                default: return 'th';
            }
        }
    </script>
</body>
</html>